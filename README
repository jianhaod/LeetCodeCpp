#LeetCodeCpp
LeetCode/C++/Solution&TestCase

This repo for solve LeetCode questions with C++ and enable some test case for each solutions.
------------------------------------------------------------------------------------------------

LeetCode problem list:
#292 Nim Game
#258 Add Digits
#104 Maximum Depth of Binary Tree  
#237 Delete Node in a Linked List
#283 Move Zeroes
#226 Invet Binary Tree
#100 Same Tree
#242 Valid Anagram
#217 Contains Dumplicate
#169 Majority Element
#235 Lowest Common Ancestor of a Binary Search Tree
#191 Number of 1 Bits

------------------------------------------------------------------------------------------------
Details Description and Expand:

#292 Nim Game
LeetCode Link:
https://leetcode.com/problems/nim-game/
Problem description:
You are playing the following Nim Game with your friend: There is a heap of stones on the table, 
each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will 
be the winner. You will take the first turn to remove the stones. Both of you are very clever and 
have optimal strategies for the game. Write a function to determine whether you can win the game 
given the number of stones in the heap.
For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, 
or 3 stones you remove, the last stone will always be removed by your friend.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/292_NimGame.cpp

Expand:


#258 Add Digits
LeetCode Link:
https://leetcode.com/problems/add-digits/
Problem descriptiocription:
Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
For example:
Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/258_AddDigits.cpp

Expand:
Could you do it without any loop/recursion in O(1) runtime?


#104 Maximum Depth of Binary Tree
LeetCode Link:
https://leetcode.com/problems/maximum-depth-of-binary-tree/
Problem description:
Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the 
longest path from the root node down to the farthest leaf node.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/104_MaximumDepthBinaryTree.cpp

Expand:
How to use non-recursive algorthim to solve this problem?


#237 Delete Node in a Linked List
LeetCode Link:
https://leetcode.com/problems/delete-node-in-a-linked-list/
Problem description:
Write a function to delete a node (except the tail) in a singly linked list, given only access to 
that node.Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 
3, the linked list should become 1 -> 2 -> 4 after calling your function.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/237_DeleteNodeInLinkList.cpp

Expand:
What about to delete a tail node?

#283 Move Zeroes
LeetCode Link:
https://leetcode.com/problems/move-zeroes/
Given an array nums, write a function to move all 0's to the end of it while maintaining the 
relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be 
[1, 3, 12, 0, 0].
Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/283_MoveZeroes.cpp

Expand:

#226 Invert Binary Tree
LeetCode Link:
https://leetcode.com/problems/invert-binary-tree/
Problem description:
Invert a binary tree.
    	   4
  	 /   \
        2     7
       / \   / \
      1   3 6   9
to
	   4
	 /   \
        7     2
       / \   / \
      9   6 3   1

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/226_InvertBinaryTree.cpp

Expand:
How to use non-recursive algorthim to solve this problem?

#100 Same Tree
LeetCode Link:
https://leetcode.com/problems/same-tree/
Problem description:
Given two binary trees, write a function to check if they are equal or not.
Two binary trees are considered equal if they are structurally identical and the nodes have the same value.


Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/100_SameTree.cpp

Expand:
How to use non-recursive algorthim to solve this problem?

#242 Valid Anagram
LeetCode Link:
https://leetcode.com/problems/valid-anagram/
Problem description:
Given two strings s and t, write a function to determine if t is an anagram of s.
For example,
s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.
Note:
You may assume the string contains only lowercase alphabets.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/242_ValidAnagram.cpp

Expand:
What if the inputs contain unicode characters? How would you adapt your solution to such case?

#217 Contains Duplicate
LeetCode Link:
https://leetcode.com/problems/contains-duplicate/
Problem description:
Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/217_ContainsDuplicate.cpp

Expand:
what about time limitation?

#169 Majority Element
LeetCode Link:
https://leetcode.com/problems/majority-element/
Problem description:
Given an array of size n, find the majority element. The majority element is the element that appears more than ? n/2 ? times.
You may assume that the array is non-empty and the majority element always exist in the array.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/169_MajorityElement.cpp

Expand:
how about the array is empty? and if no majority element is not exist?

#235 Lowest Common Ancestor of a Binary Search Tree
LeetCode Link:
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
Problem description:
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: ¡The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).
	        _______6______
	       /              \
	   ___2__          ___8__
	  /      \        /      \
         0      _4       7       9
               /  \
              3   5
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/235_LowestCommonAncestor.cpp

#191 Number of 1 Bits
LeetCode Link:
https://leetcode.com/problems/number-of-1-bits/
Problem description:
Write a function that takes an unsigned integer and returns the number of ¡1' bits it has (also known as the Hamming weight).
For example, the 32-bit integer ¡11' has binary representation 00000000000000000000000000001011, so the function should return 3.

Source code:
https://github.com/jianhaod/LeetCodeCpp/blob/master/LeetCodeCpp/191_NumberOfBits.cpp

Expand:
